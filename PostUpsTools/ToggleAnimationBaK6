using UnityEngine;
using UnityEditor;
using UnityEditor.Animations;
using UnityEditor.EditorTools;
using UnityEngine.Animations;
using Unity.EditorCoroutines.Editor;

using System;
using System.IO;
using System.Text;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;

//TODO
//Animator Functions
//Preset Settings
//Emote Menu Adder+Parameters

/*
Particle Functions:
Buffer Particle Setup
Smooth Fading
Length

Fast Audio setup
Logic
*/
public class ToggleAnimation : EditorWindow
{

    //Basic Variables

    public ToggleAnimation toggleAnimation;


    //Basic Inputs ----------------------------------------------------------------------------------------------------------------------------
    public bool customName;
    public string path;
    public string usepath;
    private string animationName;
    private string scenepath;


    //Main Objects----------------------------------------------------------------------------------------------------------------------------

    public GameObject controllergameobject;
    public AnimatorController controller;
    public Animator animator;
    public AnimationClip clip;
    public GameObject target;

    //Animator Tools ----------------------------------------------------------------------------------------------------------------------------
    public bool animatorutility;
    AnimatorStateTransition lastes;
    AnimatorState lastesstate;
    public bool bindertrigger = false;
    private AnimatorState tempState;
    public string inputText = "";

    //Transitions Tools ----------------------------------------------------------------------------------------------------------------------------
    List<Condition> conditions;

    //Absolute Menu----------------------------------------------------------------------------------------------------------------------------
    public bool quickgenerators;
    private AnimationType selectedAnimationType;


    //Data
    private AnimationType selectedOption;
    private bool isActive;
    private float volume;
    private float particleEmission;
    private Vector3 location;
    private Vector3 rotation;
    private Vector3 scale;

    //Buffers----------------------------------------------------------------------------------------------------------------------------
    private GameObject controllergameobject_buffer;
    private GameObject target_buffer;

    [MenuItem("Window/ToggleAnimation")]
    public static void ShowWindow()
    {
        EditorWindow.GetWindow(typeof(ToggleAnimation));
    }



    private void Start()
    {
        toggleAnimation = ScriptableObject.CreateInstance<ToggleAnimation>();
    }

    private void OnGUI()
    {
        if (controllergameobject_buffer != controllergameobject || target_buffer != target)
        {
            controllergameobject = controllergameobject_buffer;
            animator = controllergameobject.GetComponent<Animator>();
            controller = animator.runtimeAnimatorController as AnimatorController;
            if (controller == null) { Debug.LogError("No Controller"); }
            target = target_buffer;
            controllergameobject = controllergameobject_buffer;
            scenepath = GetRelativePathFromTo(controllergameobject_buffer, target);
            if (scenepath.EndsWith("/"))
            {
                scenepath = scenepath.Substring(0, scenepath.Length - 1);
            }
        }

        if (toggleAnimation == null)
            toggleAnimation = ScriptableObject.CreateInstance<ToggleAnimation>();

        //Inputs ------------------------------------------------------------------------------------------------------------------


        //Custom File Path
        if (GUILayout.Button("Select File"))
        {
            string selectedPath = EditorUtility.OpenFolderPanel("Select Folder Path", Application.dataPath, "");
            if (!string.IsNullOrEmpty(selectedPath))
            {
                string projectPath = Application.dataPath;
                int assetsIndex = projectPath.LastIndexOf("Assets");
                projectPath = projectPath.Substring(0, assetsIndex);
                string relativePath = selectedPath.Replace(projectPath, "");
                path = relativePath;
                usepath = path + "/";

            }
            else { usepath = "Assets/PostUpsTools/"; }
        }

        EditorGUILayout.LabelField("Selected Folder:" + usepath, EditorStyles.boldLabel);
        GUILayout.Space(20);

        if (usepath == null)
        {
            EditorGUILayout.LabelField("Select Save Folder for Animations Please!");
        }
        else
        {

            //
            customName = EditorGUILayout.Toggle("Custom Filename_OPT", customName);


            if (customName) animationName = EditorGUILayout.TextField("Animation Name:", animationName);


            controllergameobject_buffer = (GameObject)EditorGUILayout.ObjectField("Controller Object / AV:", controllergameobject_buffer, typeof(GameObject), true);
            if (controllergameobject == null)
            {
                EditorGUILayout.LabelField("Select a Object for the Controller for Showing Options (A Controller will be created called Generator in PostUpsTools Folder)");


            }
            else
            {
                //Animator and Controller
                target_buffer = (GameObject)EditorGUILayout.ObjectField("Target Object:", target_buffer, typeof(GameObject), true);
                if (target == null)
                {
                    EditorGUILayout.LabelField("Select a Target Object for Animation Options");
                    GUILayout.Space(20);
                }
                else
                {

                    //Quickgen ------------------------------------------------------------------------------------------------------------------
                    GUILayout.Space(20);
                    GUILayout.BeginVertical(GUILayout.ExpandWidth(true));

                    EditorGUILayout.LabelField("Quickanimations:", EditorStyles.boldLabel);

                    if (GUILayout.Button("Create Toggle Animations"))
                    {

                        if (!customName) animationName = target.name;
                        controller = LoadController();
                        toggleAnimation.GenerateToggles(animationName, target, animator, controller, usepath, scenepath);
                    }

                    if (GUILayout.Button("Create Linear Audio Volume"))
                    {
                        if (!customName) animationName = target.name;
                        controller = LoadController();
                        toggleAnimation.GenerateLinearAudio(animationName, target, animator, controller, usepath, scenepath);
                    }

                    if (GUILayout.Button("Create Hue Curve (Color+Emission)"))
                    {
                        if (!customName) animationName = target.name;
                        controller = LoadController();
                        toggleAnimation.GenerateHueCurve(animationName, target, animator, controller, usepath, scenepath);
                    }


                    GUILayout.EndVertical();
                    GUILayout.Space(20);



                    GUILayout.Space(30);
                    EditorGUILayout.LabelField("Extra Animation Tools:", EditorStyles.boldLabel);



                    if (GUILayout.Button("MENU Absolute Animations"))
                    {
                        quickgenerators = !quickgenerators;
                    }

                    if (quickgenerators)
                    {
                        GUILayout.Space(30);
                        GUILayout.BeginVertical();


                        //Options
                        selectedOption = (AnimationType)EditorGUILayout.EnumPopup("Select Option:", selectedOption);


                        //Animation Data
                        switch (selectedOption)
                        {

                            case AnimationType.Active:
                                isActive = EditorGUILayout.Toggle("Active", isActive);
                                break;

                            case AnimationType.Transform:
                                location = EditorGUILayout.Vector3Field("Location", location);
                                rotation = EditorGUILayout.Vector3Field("Rotation", rotation);
                                scale = EditorGUILayout.Vector3Field("Scale", scale);
                                break;

                            case AnimationType.Location:
                                location = EditorGUILayout.Vector3Field("Location", location);
                                break;

                            case AnimationType.Rotation:
                                rotation = EditorGUILayout.Vector3Field("Rotation", rotation);
                                break;

                            case AnimationType.Scale:
                                scale = EditorGUILayout.Vector3Field("Scale", scale);
                                break;

                            case AnimationType.AudioSourceVolume:
                                volume = EditorGUILayout.Slider("Volume", volume, 0.0f, 1.0f);
                                break;

                            case AnimationType.ParticleEmission:
                                particleEmission = EditorGUILayout.Slider("Volume", particleEmission, 0.0f, 300.0f);
                                break;
                        }




                        if (GUILayout.Button("Generate Selected"))
                        {
                            if (!customName) animationName = target.name;
                            controller = LoadController();



                            switch (selectedOption)
                            {

                                case AnimationType.Active:

                                    break;

                                case AnimationType.Transform:
                                    GenerateAbsoluteTransform(animationName, target, animator, controller, usepath, scenepath, location, rotation, scale);
                                    break;

                                case AnimationType.Location:
                                    GenerateAbsoluteLocation(animationName, target, animator, controller, usepath, scenepath, location);
                                    break;

                                case AnimationType.Rotation:
                                    GenerateAbsoluteRotation(animationName, target, animator, controller, usepath, scenepath, rotation);
                                    break;

                                case AnimationType.Scale:
                                    GenerateAbsoluteScale(animationName, target, animator, controller, usepath, scenepath, scale);
                                    break;

                                case AnimationType.AudioSourceVolume:
                                    GenerateAbsoluteAudio(animationName, target, animator, controller, usepath, scenepath, volume);
                                    break;

                                case AnimationType.ParticleEmission:
                                    GenerateAbsoluteParticleEmission(animationName, target, animator, controller, usepath, scenepath, particleEmission);
                                    break;
                            }
                        }

                        GUILayout.EndVertical();
                        GUILayout.Space(30);
                    }

                }
                //quickgenerators = GUILayout.Button("", GUILayout.Width(20), GUILayout.Height(20));

                EditorGUILayout.LabelField("Animator Utilitys:", EditorStyles.boldLabel);



                if (GUILayout.Button("MENU Animator Transistiontools"))
                {
                    animatorutility = !animatorutility;
                    bindertrigger = false;

                }

                if (animatorutility)
                {

                    if (GUILayout.Button("Clearnup Animator Parameters"))
                    {
                        CleanAnimatorParameters(controller);
                    }
                    //Get All Selected States in the Unity Editor

                    if (Selection.activeObject is AnimatorState)
                    {
                        if (GUILayout.Button("Batchconnect States"))
                        {
                            AnimatorState selectionstate = Selection.activeObject as AnimatorState;
                            if (selectionstate != null)
                            {
                                foreach (AnimatorState state in Selection.objects)
                                {
                                    if (state != selectionstate)
                                    {
                                        //CreateTransition(lastesstate, state_off, parameterName, 0f, AnimatorConditionMode.If, 0f, 0f, false, false, 1f);
                                        Debug.Log("" + state.name);
                                    }
                                }
                            }
                        } //lastesstate

                        //AddCondition(selectiontransition, "param", 0.0f, AnimatorConditionMode.If);


                    }

                    GUILayout.Space(30);
                    if (Selection.activeObject is AnimatorStateTransition)
                    {
                        AnimatorStateTransition selectiontransition = Selection.activeObject as AnimatorStateTransition;
                        if (selectiontransition != null)
                        {

                            EditorGUILayout.LabelField("Condition Tools:         " + selectiontransition.conditions, EditorStyles.boldLabel);

                            if (GUILayout.Button("Add Condition (Ignore)"))
                            {
                                AddCondition(selectiontransition, "param", 0.0f, AnimatorConditionMode.If);
                            }
                            GUILayout.Space(15);
                            inputText = EditorGUILayout.TextField("Parser (experimental!):", inputText);

                            if (GUILayout.Button("Generate Transitions"))
                            {
                                List<List<Dictionary<string, string>>> parsed = ParseString(inputText);

                                //Debug.Log( parsed.FindLastIndex);
                                //Debug parsed
                                AnimatorStateTransition tmp = selectiontransition;
                                int step = 1;
                                foreach (List<Dictionary<string, string>> objectList in parsed)
                                {

                                    Debug.LogWarning("Creating Transition->");

                                    foreach (Dictionary<string, string> dict in objectList)
                                    {

                                        ParseAndAddCondition(tmp, dict, controller);
                                        Debug.Log(dict["parameter"] + " " + dict["operator"] + " " + dict["secondParameter"]);
                                    }
                                    //gettng for each step the count of the parsed list
                                    step++;
                                    if (step > 1 && step <= parsed.Count)
                                        tmp = AddDuplicate(selectiontransition, controller);

                                }

                                EditorUtility.SetDirty(controller);
                                AssetDatabase.SaveAssets();
                                AssetDatabase.Refresh();

                                DeselectAll(controller);
                            }

                            if (GUILayout.Button("Generate Inverted Transitions"))
                            {
                                List<List<Dictionary<string, string>>> parsed = ParseString(ReverseConditionString(inputText));
                                Debug.LogWarning("This Function is Unfinished");

                                AnimatorStateTransition tmp = AddDuplicateReversed(selectiontransition, controller);
                                int step = 1;
                                foreach (List<Dictionary<string, string>> objectList in parsed)
                                {

                                    Debug.LogWarning("Creating Transition->");

                                    foreach (Dictionary<string, string> dict in objectList)
                                    {

                                        ParseAndAddCondition(tmp, dict, controller);
                                        Debug.Log(dict["parameter"] + " " + dict["operator"] + " " + dict["secondParameter"]);
                                    }

                                    step++;
                                    if (step > 1 && step <= parsed.Count)
                                        tmp = AddDuplicateReversed(selectiontransition, controller);
                                }

                                EditorUtility.SetDirty(controller);
                                AssetDatabase.SaveAssets();
                                AssetDatabase.Refresh();

                                DeselectAll(controller);
                            }





                            if (!bindertrigger)
                                if (GUILayout.Button("Rebind"))
                                {
                                    lastes = selectiontransition;
                                    bindertrigger = true;
                                }
                        }
                    }
                    else if (!bindertrigger) EditorGUILayout.LabelField("No Transistion Selected", EditorStyles.boldLabel);


                    if (bindertrigger)
                    {
                        EditorGUILayout.LabelField("Select Animator State to Rebind", EditorStyles.boldLabel);
                        if (GUILayout.Button("Cancel Rebind"))
                        {

                        }
                    }

                    if (Selection.activeObject != null)
                        if (Selection.activeObject.GetType() == typeof(AnimatorState) && bindertrigger)
                        {
                            Debug.LogWarning("Rebinding...");
                            ChangeTransitionDestination(lastes, Selection.activeObject as AnimatorState, controller);
                            bindertrigger = false;

                            //Update Window
                            tempState = AddTemptstate(controller, lastes);
                            EditorCoroutineUtility.StartCoroutine(DelayedFunction(controller, tempState), this);
                        }

                }

                if (GUILayout.Button("MENU Transition Parser"))
                {
                    animatorutility = !animatorutility;
                    bindertrigger = false;

                }




            }
        }
    }

    //Method to deselect all objects in the unity editor animator window
    private void DeselectAll(AnimatorController controller)
    {
        AnimatorStateMachine stateMachine = controller.layers[0].stateMachine;
        foreach (ChildAnimatorState state in stateMachine.states)
        {
            state.state.motion = null;
        }
    }

    private AnimatorController LoadController()
    {
        string controllerPath = "Assets/PostUpsTools/Generator.controller";
        AnimatorController existingController = AssetDatabase.LoadAssetAtPath<AnimatorController>(controllerPath);
        if (existingController == null)
        {
            return AnimatorController.CreateAnimatorControllerAtPath(controllerPath);
        }
        else
        {
            return existingController;
        }
    }

    private IEnumerator DelayedFunction(AnimatorController controller, AnimatorState tempState)
    {
        Debug.Log("Function started");

        yield return new WaitForSeconds(1.0f);
        RemoveTempstate(controller, tempState);
        Debug.Log("Function finished");
    }

    private string GetRelativePathFromTo(GameObject from, GameObject to)
    {
        Transform fromTransform = from.transform;
        Transform toTransform = to.transform;

        string path = "";
        Transform currentTransform = toTransform;

        while (currentTransform != fromTransform)
        {
            path = currentTransform.name + "/" + path;
            currentTransform = currentTransform.parent;

            if (currentTransform == null)
            {
                Debug.LogError("The 'to' GameObject is not a child of the 'from' GameObject.");
                return null;
            }
        }
        return path;
    }

    private void Save(AnimationClip clip, string filepath, string filename, string fileaddition, AnimatorController controller, Animator animator)
    {
        if (!File.Exists(filepath + filename + fileaddition))
        {
            AssetDatabase.CreateAsset(clip, filepath + filename + fileaddition);
            EditorUtility.SetDirty(controller);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();

            Debug.Log("Generating Done!");
        }
        else
        {
            Debug.LogError("File  " + filepath + filename + fileaddition + " Already Exists");
        }
    }

    private void SetLinearTangent(AnimationCurve curve, int index)
    {
        Keyframe keyframe = curve[index];

        if (index == 0)
        {
            // First keyframe
            keyframe.inTangent = 0f;
        }
        else
        {
            // Calculate the tangent based on the previous keyframe
            Keyframe prevKeyframe = curve[index - 1];
            float deltaX = keyframe.time - prevKeyframe.time;
            float deltaY = keyframe.value - prevKeyframe.value;
            keyframe.inTangent = deltaY / deltaX;
        }

        if (index == curve.length - 1)
        {
            // Last keyframe
            keyframe.outTangent = 0f;
        }
        else
        {
            // Calculate the tangent based on the next keyframe
            Keyframe nextKeyframe = curve[index + 1];
            float deltaX = nextKeyframe.time - keyframe.time;
            float deltaY = nextKeyframe.value - keyframe.value;
            keyframe.outTangent = deltaY / deltaX;
        }

        curve.MoveKey(index, keyframe);
    }

    //Generators----------------------------------------------------------------------------------------------------------------------------
    public void GenerateToggles(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath)
    {
        Debug.Log("Generating Toggles for " + target.name + " ...");
        AnimationClip clip_on;
        AnimationClip clip_off;

        //Create Clip
        clip_on = new AnimationClip();
        clip_on.name = animationName + "_on";
        AnimationCurve curve_on = new AnimationCurve();
        curve_on.AddKey(0f, 1f);
        clip_on.SetCurve(scenepath, typeof(GameObject), "m_IsActive", curve_on);

        //Add and Save Clip
        controller.AddMotion(clip_on);

        //Create Clip Off
        clip_off = new AnimationClip();
        clip_off.name = animationName + "_off";
        AnimationCurve curve_off = new AnimationCurve();
        curve_off.AddKey(0f, 0f);
        clip_off.SetCurve(scenepath, typeof(GameObject), "m_IsActive", curve_off);
        controller.AddMotion(clip_off);

        //Add and Save Clip
        if ((!File.Exists(usepath + "_on.anim") && !File.Exists(usepath + "_off.anim")))
        {
            AssetDatabase.CreateAsset(clip_on, usepath + "" + animationName + "_on.anim");
            AssetDatabase.CreateAsset(clip_off, usepath + "" + animationName + "_off.anim");
            CreateAnimatorToggles(target, animator, controller, clip_on, clip_off);
            Debug.Log("Generating Done!");
        }
        else
        {
            if (!(File.Exists(usepath + "_on.anim")))
                Debug.LogError("File >" + usepath + animationName + "_on.anim Already Exists");
            if (!(File.Exists(usepath + "_off.anim")))
                Debug.LogError("File >" + usepath + animationName + "_off.anim Already Exists");
        }

    }

    public void GenerateLinearAudio(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath)
    {
        Debug.Log("Generating Linear Audio for " + target.name + " ...");

        //Create Clip
        clip = new AnimationClip();
        clip.name = animationName + "_linearaudio";
        AnimationCurve curve = AnimationCurve.Linear(0f, 0.0f, 1.0f, 1.0f);
        curve.AddKey(0f, 1f);
        clip.SetCurve(scenepath, typeof(AudioSource), "m_Volume", curve);

        //Add and Save Clip
        controller.AddMotion(clip);
        Save(clip, usepath, animationName, "_linearaudio.anim", controller, animator);

    }

    public void GenerateAbsoluteAudio(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath, float strength)
    {
        Debug.Log("Generating Absolute Audio for " + target.name + " ...");

        //Create Clip
        clip = new AnimationClip();
        clip.name = animationName + "_absoluteaudio";
        AnimationCurve curve = new AnimationCurve();
        curve.AddKey(0f, strength);
        clip.SetCurve(scenepath, typeof(AudioSource), "m_Volume", curve);

        //Add and Save Clip
        controller.AddMotion(clip);
        Save(clip, usepath, animationName, "_absoluteaudio.anim", controller, animator);

    }

    public void GenerateAbsoluteParticleEmission(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath, float strength)
    {
        Debug.Log("Generating Absolute ParticleEmission for " + target.name + " ...");

        //Create Clip
        clip = new AnimationClip();
        clip.name = animationName + "_absoluteparticleemission";
        AnimationCurve curve = new AnimationCurve();
        curve.AddKey(0f, strength);
        clip.SetCurve(scenepath, typeof(ParticleSystem), "EmissionModule.rateOverTime.scalar", curve);

        //Add and Save Clip
        controller.AddMotion(clip);
        Save(clip, usepath, animationName, "_absoluteparticleemission.anim", controller, animator);

    }

    public void GenerateHueCurve(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath)
    {
        Debug.Log("Generating Hue Curve for " + target.name + " ...");

        //Create Clip
        clip = new AnimationClip();
        clip.name = animationName + "_huecurve";

        AnimationCurve curveR = new AnimationCurve();
        AnimationCurve curveG = new AnimationCurve();
        AnimationCurve curveB = new AnimationCurve();
        AnimationCurve curveA = new AnimationCurve();

        float[] rValues = new float[] { 1f, 1f, 0f, 0f, 0f, 1f, 1f };
        float[] gValues = new float[] { 0f, 1f, 1f, 1f, 0f, 0f, 0f };
        float[] bValues = new float[] { 0f, 0f, 0f, 1f, 1f, 1f, 0f };

        for (int i = 0; i < 7; i++)
        {
            float time = i / 6f;
            curveR.AddKey(time, rValues[i]);
            curveG.AddKey(time, gValues[i]);
            curveB.AddKey(time, bValues[i]);
        }


        for (int i = 0; i < curveR.length; i++)
        {
            SetLinearTangent(curveR, i);
            SetLinearTangent(curveG, i);
            SetLinearTangent(curveB, i);
        }




        curveA.AddKey(0.0f, 1.0f);
        curveA.AddKey(1.0f, 1.0f);

        clip.SetCurve(scenepath, typeof(MeshRenderer), "material._EmissionColor.r", curveR);
        clip.SetCurve(scenepath, typeof(MeshRenderer), "material._EmissionColor.g", curveG);
        clip.SetCurve(scenepath, typeof(MeshRenderer), "material._EmissionColor.b", curveB);

        clip.SetCurve(scenepath, typeof(MeshRenderer), "material._Color.r", curveR);
        clip.SetCurve(scenepath, typeof(MeshRenderer), "material._Color.g", curveG);
        clip.SetCurve(scenepath, typeof(MeshRenderer), "material._Color.b", curveB);
        clip.SetCurve(scenepath, typeof(MeshRenderer), "material._Color.a", curveA);

        //Add and Save Clip

        controller.AddMotion(clip);
        Save(clip, usepath, animationName, "_huecurve.anim", controller, animator);

    }

    public void GenerateAbsoluteTransform(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath, Vector3 Location, Vector3 Rotation, Vector3 Scale)
    {
        Debug.Log("Generating Absolute Transforms for " + target.name + " ...");
        //Create Clip
        clip = new AnimationClip();
        clip.name = animationName + "_transform";

        // Create keyframe for the location
        clip.SetCurve(scenepath, typeof(Transform), "localPosition.x", AnimationCurve.Constant(0f, clip.length, Location.x));
        clip.SetCurve(scenepath, typeof(Transform), "localPosition.y", AnimationCurve.Constant(0f, clip.length, Location.y));
        clip.SetCurve(scenepath, typeof(Transform), "localPosition.z", AnimationCurve.Constant(0f, clip.length, Location.z));

        // Create keyframe for the rotation
        clip.SetCurve(scenepath, typeof(Transform), "localEulerAnglesRaw.x", AnimationCurve.Constant(0f, clip.length, Rotation.x));
        clip.SetCurve(scenepath, typeof(Transform), "localEulerAnglesRaw.y", AnimationCurve.Constant(0f, clip.length, Rotation.y));
        clip.SetCurve(scenepath, typeof(Transform), "localEulerAnglesRaw.z", AnimationCurve.Constant(0f, clip.length, Rotation.z));

        // Create keyframe for the scale
        clip.SetCurve(scenepath, typeof(Transform), "localScale.x", AnimationCurve.Constant(0f, clip.length, Scale.x));
        clip.SetCurve(scenepath, typeof(Transform), "localScale.y", AnimationCurve.Constant(0f, clip.length, Scale.y));
        clip.SetCurve(scenepath, typeof(Transform), "localScale.z", AnimationCurve.Constant(0f, clip.length, Scale.z));

        //Add and Save Clip
        controller.AddMotion(clip);
        Save(clip, usepath, animationName, "_tranform.anim", controller, animator);

    }

    public void GenerateAbsoluteLocation(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath, Vector3 Location)
    {
        Debug.Log("Generating Absolute Locations for " + target.name + " ...");
        //Create Clip
        clip = new AnimationClip();
        clip.name = animationName + "_location";

        // Create keyframe for the location
        clip.SetCurve(scenepath, typeof(Transform), "localPosition.x", AnimationCurve.Constant(0f, clip.length, Location.x));
        clip.SetCurve(scenepath, typeof(Transform), "localPosition.y", AnimationCurve.Constant(0f, clip.length, Location.y));
        clip.SetCurve(scenepath, typeof(Transform), "localPosition.z", AnimationCurve.Constant(0f, clip.length, Location.z));


        //Add and Save Clip
        controller.AddMotion(clip);
        Save(clip, usepath, animationName, "_location.anim", controller, animator);

    }

    public void GenerateAbsoluteRotation(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath, Vector3 Rotation)
    {
        Debug.Log("Generating Absolute Rotations for " + target.name + " ...");
        //Create Clip
        clip = new AnimationClip();
        clip.name = animationName + "_rotation";

        // Create keyframe for the rotation
        clip.SetCurve(scenepath, typeof(Transform), "localEulerAnglesRaw.x", AnimationCurve.Constant(0f, clip.length, Rotation.x));
        clip.SetCurve(scenepath, typeof(Transform), "localEulerAnglesRaw.y", AnimationCurve.Constant(0f, clip.length, Rotation.y));
        clip.SetCurve(scenepath, typeof(Transform), "localEulerAnglesRaw.z", AnimationCurve.Constant(0f, clip.length, Rotation.z));


        //Add and Save Clip
        controller.AddMotion(clip);
        Save(clip, usepath, animationName, "_rotation.anim", controller, animator);
    }

    public void GenerateAbsoluteScale(string animationName, GameObject target, Animator animator, AnimatorController controller, string usepath, string scenepath, Vector3 Scale)
    {
        Debug.Log("Generating Absolute Scales for " + target.name + " ...");
        //Create Clip
        clip = new AnimationClip();
        clip.name = animationName + "_scales";


        // Create keyframe for the scale
        clip.SetCurve(scenepath, typeof(Transform), "localScale.x", AnimationCurve.Constant(0f, clip.length, Scale.x));
        clip.SetCurve(scenepath, typeof(Transform), "localScale.y", AnimationCurve.Constant(0f, clip.length, Scale.y));
        clip.SetCurve(scenepath, typeof(Transform), "localScale.z", AnimationCurve.Constant(0f, clip.length, Scale.z));

        //Add and Save Clip
        controller.AddMotion(clip);
        Save(clip, usepath, animationName, "_scales.anim", controller, animator);

    }

    private enum AnimationType
    {
        Active,
        Transform,
        Location,
        Rotation,
        Scale,
        AudioSourceVolume,
        ParticleEmission
    }

    //Animator Creation Tools----------------------------------------------------------------------------------------------------------------------------
    public void CreateAnimatorToggles(GameObject target, Animator animator, AnimatorController controller, AnimationClip clip_on, AnimationClip clip_off)
    {

        AddClipsAndTransition(controller, clip_on, clip_off, target.name + " toggle", target.name + " toggle");

    }

    private void AddClipsAndTransition(AnimatorController controller, AnimationClip clip_on, AnimationClip clip_off, string layerName, string parameterName)
    {
        AddLayerIfNotExists(controller, layerName);
        AnimatorControllerLayer layer = controller.layers.FirstOrDefault(l => l.name == layerName);
        AnimatorStateMachine stateMachine = layer.stateMachine;
        layer.defaultWeight = 1.0f;

        AddBoolParameterIfNotExists(controller, parameterName);

        AnimatorControllerLayer newLayer = controller.layers[controller.layers.Length - 1];

        AnimatorState state_on = newLayer.stateMachine.AddState("clip_on");
        state_on.motion = clip_on;

        AnimatorState state_off = newLayer.stateMachine.AddState("clip_off");
        state_off.motion = clip_off;

        AnimatorStateTransition transition1 = CreateTransition(state_on, state_off, parameterName, 0f, AnimatorConditionMode.If, 0f, 0f, false, false, 1f);
        AnimatorStateTransition transition2 = CreateTransition(state_off, state_on, parameterName, 0f, AnimatorConditionMode.IfNot, 0f, 0f, false, false, 1f);

        AssetDatabase.AddObjectToAsset(transition1, controller);
        AssetDatabase.AddObjectToAsset(transition2, controller);

        EditorUtility.SetDirty(clip_on);
        EditorUtility.SetDirty(clip_off);
        EditorUtility.SetDirty(controller);
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
    }
    //Parameter Tools----------------------------------------------------------------------------------------------------------------------------

    //Function clean deletes parameters on an Animator that arent used
    public void CleanAnimatorParameters(AnimatorController controller)
    {
        //get existing parameters
        AnimatorControllerParameter[] parameters = controller.parameters;

        //get all states
        AnimatorStateMachine stateMachine = controller.layers[0].stateMachine;
        AnimatorState[] states = stateMachine.states.Select(s => s.state).ToArray();

        //get all transitions
        AnimatorStateTransition[] transitions = states.SelectMany(s => s.transitions).ToArray();

        //get all conditions
        AnimatorCondition[] conditions = transitions.SelectMany(t => t.conditions).ToArray();

        //get all parameters used in conditions
        string[] usedParameters = conditions.Select(c => c.parameter).ToArray();

        //remove all parameters that are not used
        /*
        AnimatorControllerParameter[] newParameters = parameters.Where(p => usedParameters.Contains(p.name)).ToArray();
        controller.parameters = newParameters;
        */

        //remove parameters that is not in usedParameters
        foreach (AnimatorControllerParameter parameter in parameters)
        {
            if (!usedParameters.Contains(parameter.name))
            {
                Debug.Log("Removing: " + parameter.name);
                controller.RemoveParameter(parameter);
            }
        }

    }

    private void AddBoolParameterIfNotExists(AnimatorController controller, string parameterName)
    {
        AnimatorControllerParameter[] parameters = controller.parameters;
        AnimatorControllerParameter leverParam = parameters.FirstOrDefault(p => p.name == parameterName);

        if (leverParam == null)
        {
            leverParam = new AnimatorControllerParameter();
            leverParam.name = parameterName;
            leverParam.type = AnimatorControllerParameterType.Bool;

            int paramCount = parameters.Length;
            AnimatorControllerParameter[] newParams = new AnimatorControllerParameter[paramCount + 1];

            for (int i = 0; i < paramCount; i++)
            {
                newParams[i] = parameters[i];
            }

            newParams[paramCount] = leverParam;
            controller.parameters = newParams;
        }
    }

    public static bool ParameterExists(AnimatorController controller, string name)
    {
        AnimatorControllerParameter param = controller.parameters.FirstOrDefault(p => p.name == name);
        return (param != null);
    }
    public static AnimatorControllerParameterType GetParameterType(AnimatorController controller, string name)
    {
        AnimatorControllerParameter[] parameters = controller.parameters;
        AnimatorControllerParameter param = parameters.FirstOrDefault(p => p.name == name);

        return param.type;
    }

    public static void CreateParameter(AnimatorController controller, string name, AnimatorControllerParameterType type)
    {
        AnimatorControllerParameter[] parameters = controller.parameters;
        AnimatorControllerParameter param = parameters.FirstOrDefault(p => p.name == name);

        if (param == null)
        {
            param = new AnimatorControllerParameter();
            param.name = name;
            param.type = type;

            int paramCount = parameters.Length;
            AnimatorControllerParameter[] newParams = new AnimatorControllerParameter[paramCount + 1];

            for (int i = 0; i < paramCount; i++)
            {
                newParams[i] = parameters[i];
            }

            newParams[paramCount] = param;
            controller.parameters = newParams;
        }
    }

    private void AddLayerIfNotExists(AnimatorController controller, string name)
    {
        AnimatorControllerLayer layer = controller.layers.FirstOrDefault(l => l.name == name);

        if (layer == null)
        {
            layer = new AnimatorControllerLayer();
            layer.name = name;
            layer.stateMachine = new AnimatorStateMachine();

            AssetDatabase.AddObjectToAsset(layer.stateMachine, controller);

            int layerCount = controller.layers.Length;
            AnimatorControllerLayer[] newLayers = new AnimatorControllerLayer[layerCount + 1];

            for (int i = 0; i < layerCount; i++)
            {
                newLayers[i] = controller.layers[i];
            }

            newLayers[layerCount] = layer;
            controller.layers = newLayers;

            EditorUtility.SetDirty(controller);

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }
    }





    private AnimatorStateTransition CreateTransition(AnimatorState sourceState, AnimatorState destinationState, string parameter, float threshold, AnimatorConditionMode conditionType, float duration, float offset, bool isExit, bool hasExitTime, float exitTime)
    {
        AnimatorStateTransition transition = new AnimatorStateTransition();

        transition.destinationState = destinationState;
        transition.isExit = isExit;
        transition.hasExitTime = hasExitTime;
        transition.duration = duration;
        transition.offset = offset;
        transition.AddCondition(conditionType, threshold, parameter);
        transition.exitTime = exitTime;
        sourceState.AddTransition(transition);

        return transition;
    }

    //NOTES: >= and <= are bugged
    public static string ReverseConditionString(string input)
    {
        string output = "";
        int i = 0;
        while (i < input.Length)
        {
            if (i < input.Length - 1 && input[i] == '&' && input[i + 1] == '&')
            {
                output += "||";
                i += 2;
            }
            else if (i < input.Length - 1 && input[i] == '|' && input[i + 1] == '|')
            {
                output += "&&";
                i += 2;
            }
            else if (input[i] == '>' && (i == input.Length - 1 || input[i + 1] != '='))
            {
                output += "<";
                i += 1;
            }
            else if (input[i] == '<' && (i == input.Length - 1 || input[i + 1] != '='))
            {
                output += ">";
                i += 1;
            }
            else if (i < input.Length - 1 && input[i] == '>' && input[i + 1] == '=')
            {
                output += "<=";
                i += 2;
            }
            else if (i < input.Length - 1 && input[i] == '<' && input[i + 1] == '=')
            {
                output += ">=";
                i += 2;
            }
            else if (i < input.Length - 1 && input[i] == '=' && input[i + 1] == '=')
            {
                output += "!=";
                i += 2;
            }
            else if (i < input.Length - 1 && input[i] == '!' && input[i + 1] == '=')
            {
                output += "==";
                i += 2;
            }
            else
            {
                output += input[i];
                i += 1;
            }
        }

        return output;
    }

    //Parser Tools------------------------------------------------------------------------------------------------------------------------------
    public static void ParseAndAddCondition(AnimatorStateTransition transition, Dictionary<string, string> dict, AnimatorController controller)
    {
        string parameter = dict["parameter"];
        string operatorStr = dict["operator"];
        string secondParameterStr = dict["secondParameter"];

        //add parameter if it doesn't exist
        if (!ParameterExists(controller, parameter))
        {
            //get the parameter type
            AnimatorControllerParameterType type = AnimatorControllerParameterType.Float;
            if (secondParameterStr == "true" || secondParameterStr == "false")
            {
                type = AnimatorControllerParameterType.Bool;
            }
            //if is equals or not equals, set int
            else if (operatorStr == "==" || operatorStr == "!=")
            {
                type = AnimatorControllerParameterType.Int;
            }
            //if not containing commas or dots
            else if (!secondParameterStr.Contains(",") && !secondParameterStr.Contains("."))
            {
                type = AnimatorControllerParameterType.Int;
            }

            Debug.Log("Adding by Type:" + type);
            CreateParameter(controller, parameter, type);


        }

        // Parse the second parameter if it's "true" or "false"
        /*
        bool secondParameterBool;
        if (bool.TryParse(secondParameterStr, out secondParameterBool))
        {
            secondParameterStr = secondParameterBool.ToString();
        }
        */

        // set secondParameterStr to 1 or 0 if true or false
        if (secondParameterStr == "true")
        {
            secondParameterStr = "1";
        }
        else if (secondParameterStr == "false")
        {
            secondParameterStr = "0";
        }

        // Parse the operator
        AnimatorConditionMode conditionType = AnimatorConditionMode.Equals;
        switch (operatorStr)
        {
            case ">":
                conditionType = AnimatorConditionMode.Greater;
                break;
            case "<":
                conditionType = AnimatorConditionMode.Less;
                break;
            case ">=":
                dict["operator"] = ">";
                ParseAndAddCondition(transition, dict, controller);
                conditionType = AnimatorConditionMode.Equals;
                break;
            case "<=":
                dict["operator"] = "<";
                ParseAndAddCondition(transition, dict, controller);
                conditionType = AnimatorConditionMode.Equals;
                break;
            case "==":
                conditionType = AnimatorConditionMode.Equals;
                break;
            case "=":
                conditionType = AnimatorConditionMode.Equals;
                break;
            case "!=":
                conditionType = AnimatorConditionMode.NotEqual;
                break;
            default:
                // Invalid operator, do something
                break;
        }

        // Parse the threshold as a float
        //replace secondParameterStr . with , for float parsing
        secondParameterStr = secondParameterStr.Replace(".", ",");
        float threshold;
        if (!float.TryParse(secondParameterStr, out threshold))
        {
            // Invalid threshold, do something
            return;
        }

        // Add the condition to the transition
        transition.AddCondition(conditionType, threshold, RemoveBrackets(parameter));
    }

    public static string RemoveBrackets(string input)
    {
        // Define a regular expression to match round and square brackets
        Regex regex = new Regex(@"[\[\]]|\(|\)");

        // Replace all instances of brackets with an empty string
        string output = regex.Replace(input, "");

        return output;
    }

    public static List<string> Tokenize(string input)
    {
        char[] separators = new char[] { '(', ')', ' ', '&', '|', '=', '!', '>', '<' };
        List<string> tokens = new List<string>();
        int start = 0;
        int end = 0;

        while (end < input.Length)
        {
            while (end < input.Length && Array.IndexOf(separators, input[end]) == -1)
            {
                end++;
            }

            tokens.Add(input.Substring(start, end - start));
            end++;
            start = end;
        }

        return tokens;
    }



    /*
    private static List<Dictionary<string, string>> ParseCondition(string condition)
    {
        List<Dictionary<string, string>> objectList = new List<Dictionary<string, string>>();
        string[] subConditions = SplitTopLevel(condition, "||");
        foreach (string subCondition in subConditions)
        {
            string[] parts = SplitTopLevel(subCondition, "&&");
            foreach (string part in parts)
            {
                Match match = Regex.Match(part, @"^(.*?)([=!><]+)(.*?)$");
                if (match.Success)
                {
                    Dictionary<string, string> dict = new Dictionary<string, string>
                    {
                        { "parameter", match.Groups[1].Value.Trim() },
                        { "operator", match.Groups[2].Value.Trim() },
                        { "secondParameter", match.Groups[3].Value.Trim() }
                    };
                    objectList.Add(dict);
                }
            }
        }

        // Output the list of dictionaries to the console
        Console.WriteLine("List of dictionaries:");
        foreach (Dictionary<string, string> dict in objectList)
        {
            foreach (KeyValuePair<string, string> kvp in dict)
            {
                Console.WriteLine("{0}: {1}", kvp.Key, kvp.Value);
            }
            Console.WriteLine();
        }

        return objectList;
    }

    private static string[] SplitTopLevel(string str, string op)
    {
        int level = 0;
        List<string> parts = new List<string>();
        int startIndex = 0;
        for (int i = 0; i < str.Length; i++)
        {
            if (str[i] == '(')
            {
                level++;
            }
            else if (str[i] == ')')
            {
                level--;
            }
            else if (level == 0 && str.Substring(i, op.Length) == op)
            {
                parts.Add(str.Substring(startIndex, i - startIndex));
                startIndex = i + op.Length;
            }
        }
        parts.Add(str.Substring(startIndex));
        return parts.ToArray();
    }





    */
    /* better deprecated*/
    public static List<List<Dictionary<string, string>>> ParseString(string str)
    {
        List<List<Dictionary<string, string>>> result = new List<List<Dictionary<string, string>>>();

        int startIndex = str.IndexOf("if(");
        int endIndex = str.LastIndexOf(")");

        if (startIndex != -1 && endIndex != -1)
        {
            string condition = str.Substring(startIndex + 3, endIndex - startIndex - 3);
            string[] subConditions = condition.Split(new string[] { "||" }, System.StringSplitOptions.None);
            foreach (string subCondition in subConditions)
            {
                string[] parts = subCondition.Split(new string[] { "&&" }, System.StringSplitOptions.None);
                List<Dictionary<string, string>> objectList = new List<Dictionary<string, string>>();
                foreach (string part in parts)
                {
                    Match match = Regex.Match(part, @"^(.*?)([=!><]+)(.*?)$");
                    if (match.Success)
                    {
                        Dictionary<string, string> dict = new Dictionary<string, string>
                    {
                        { "parameter", match.Groups[1].Value.Trim('(', ')', ' ') },
                        { "operator", match.Groups[2].Value.Trim() },
                        { "secondParameter", match.Groups[3].Value.Trim('(', ')', ' ') }
                    };
                        objectList.Add(dict);
                    }
                }
                if (objectList.Count > 0)
                {
                    result.Add(objectList);
                }
            }
        }

        return result;
    }

    /**/
    /* deprecated code
        public static List<List<Dictionary<string, string>>> ParseString(string str)
    {
        List<List<Dictionary<string, string>>> result = new List<List<Dictionary<string, string>>>();

        int startIndex = str.IndexOf("if(");
        int endIndex = str.IndexOf(")");

        if (startIndex != -1 && endIndex != -1)
        {
            string condition = str.Substring(startIndex + 3, endIndex - startIndex - 3);
            str = str.Substring(endIndex + 1);
            string[] subConditions = condition.Split(new string[] { " || " }, System.StringSplitOptions.None);
            List<Dictionary<string, string>> currentConditions = new List<Dictionary<string, string>>();
            foreach (string subCondition in subConditions)
            {
                string[] parts = subCondition.Split(new string[] { " && " }, System.StringSplitOptions.None);
                List<Dictionary<string, string>> objectList = new List<Dictionary<string, string>>();
                if (currentConditions.Count > 0)
                {
                    objectList.AddRange(currentConditions.GetRange(0, currentConditions.Count - 1));
                }
                foreach (string part in parts)
                {
                    Match match = Regex.Match(part, @"^(.*?)([=!><]+)(.*?)$");
                    if (match.Success)
                    {
                        Dictionary<string, string> dict = new Dictionary<string, string>
                        {
                            { "parameter", match.Groups[1].Value.Trim() },
                            { "operator", match.Groups[2].Value.Trim() },
                            { "secondParameter", match.Groups[3].Value.Trim() }
                        };
                        objectList.Add(dict);
                    }
                }
                if (objectList.Count > 0)
                {
                    result.Add(objectList);
                    currentConditions = objectList;
                }
            }
        }

        return result;
    }
    */

    //Animator State Tools------------------------------------------------------------------------------------------------------------------------------




    //script for duplication a transition on the same state
    public AnimatorStateTransition AddDuplicate(AnimatorStateTransition originalTransition, AnimatorController controller)
    {

        //AnimatorState source = GetSourceState(controller, originalTransition);
        AnimatorState source = originalTransition.destinationState;
        AnimatorState parent = GetParentState(controller, originalTransition);

        AnimatorStateTransition newTransition = parent.AddTransition(source);
        newTransition.duration = originalTransition.duration;
        newTransition.offset = originalTransition.offset;
        newTransition.exitTime = originalTransition.exitTime;
        newTransition.hasExitTime = originalTransition.hasExitTime;
        newTransition.interruptionSource = originalTransition.interruptionSource;
        newTransition.orderedInterruption = originalTransition.orderedInterruption;
        newTransition.mute = originalTransition.mute;
        newTransition.solo = originalTransition.solo;
        newTransition.canTransitionToSelf = originalTransition.canTransitionToSelf;
        return newTransition;
    }

    public AnimatorStateTransition AddDuplicateReversed(AnimatorStateTransition originalTransition, AnimatorController controller)
    {

        //AnimatorState source = GetSourceState(controller, originalTransition);
        AnimatorState source = originalTransition.destinationState;
        AnimatorState parent = GetParentState(controller, originalTransition);

        AnimatorStateTransition newTransition = source.AddTransition(parent);
        newTransition.duration = originalTransition.duration;
        newTransition.offset = originalTransition.offset;
        newTransition.exitTime = originalTransition.exitTime;
        newTransition.hasExitTime = originalTransition.hasExitTime;
        newTransition.interruptionSource = originalTransition.interruptionSource;
        newTransition.orderedInterruption = originalTransition.orderedInterruption;
        newTransition.mute = originalTransition.mute;
        newTransition.solo = originalTransition.solo;
        newTransition.canTransitionToSelf = originalTransition.canTransitionToSelf;
        return newTransition;
    }

    private void AddCondition(AnimatorStateTransition transition, string parameter, float threshold, AnimatorConditionMode conditionType)
    {
        AnimatorCondition[] conditions = transition.conditions;
        AnimatorCondition newCondition = new AnimatorCondition();
        //newCondition.parameter = parameter;
        //newCondition.threshold = threshold;
        //newCondition.mode = conditionType;
        AnimatorCondition[] newConditions = new AnimatorCondition[conditions.Length + 1];
        for (int i = 0; i < conditions.Length; i++)
        {
            newConditions[i] = conditions[i];
        }
        newConditions[newConditions.Length - 1] = newCondition;
        transition.conditions = newConditions;

    }

    private void ChangeTransitionDestination(AnimatorStateTransition transition, AnimatorState newState, AnimatorController controller)
    {
        // Change the destination state of the transition to the new state
        transition.destinationState = newState;
    }

    //Trigger Update Tools------------------------------------------------------------------------------------------------------------------------------
    private void ForceUpdates()
    {
        EditorApplication.RepaintHierarchyWindow();
        EditorApplication.QueuePlayerLoopUpdate();
    }

    private AnimatorState AddTemptstate(AnimatorController controller, AnimatorStateTransition transition)
    {

        int activelayer = 0;

        //Find the Layer of the Animator State Transition without using parentStateMaschine
        for (int i = 0; i < controller.layers.Length; i++)
        {
            for (int j = 0; j < controller.layers[i].stateMachine.states.Length; j++)
            {
                if (controller.layers[i].stateMachine.states[j].state == transition.destinationState)
                {
                    activelayer = i;
                }
            }
        }

        //adding the state to the current active layer
        AnimatorState state = controller.layers[activelayer].stateMachine.AddState("Delete if not removed after 10s");
        return state;
    }

    private void RemoveTempstate(AnimatorController controller, AnimatorState tempState)
    {

        if (tempState == null)
        {
            Debug.LogWarning("Cannot remove null state.");
            return;
        }



        //Find the layer of the Animator State Transition without using parentStateMaschine if not found Debug Log
        int activelayer = 0;
        for (int i = 0; i < controller.layers.Length; i++)
        {
            for (int j = 0; j < controller.layers[i].stateMachine.states.Length; j++)
            {
                if (controller.layers[i].stateMachine.states[j].state == tempState)
                {
                    activelayer = i;
                }
            }
        }

        // Remove the state from the controller
        controller.layers[activelayer].stateMachine.RemoveState(tempState);

        // Log a message to indicate that the state has been removed
        Debug.Log("Temporary state removed from animator controller.");
    }



    //Animator Functions----------------------------------------------------------------------------------------------------------------------------

    //Function to update Unity Editor Animator to Show changes 
    private void UpdateAnimator(AnimatorController controller)
    {
        //Force Unity to update the Animator
        EditorUtility.SetDirty(controller);
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
    }

    //State Functions----------------------------------------------------------------------------------------------------------------------------

    private bool HasState(AnimatorController controller, string stateName)
    {
        int stateCount = controller.layers[0].stateMachine.states.Length;
        for (int i = 0; i < stateCount; i++)
        {
            if (controller.layers[0].stateMachine.states[i].state.name == stateName)
            {
                return true;
            }
        }
        return false;
    }

    private bool HasLayer(AnimatorController controller, string layerName)
    {
        int layerCount = controller.layers.Length;
        for (int i = 0; i < layerCount; i++)
        {
            if (controller.layers[i].name == layerName)
            {
                return true;
            }
        }
        return false;
    }

    private AnimatorState GetState(AnimatorController controller, string stateName)
    {
        int stateCount = controller.layers[0].stateMachine.states.Length;
        for (int i = 0; i < stateCount; i++)
        {
            if (controller.layers[0].stateMachine.states[i].state.name == stateName)
            {
                return controller.layers[0].stateMachine.states[i].state;
            }
        }
        return null;
    }

    private AnimatorControllerLayer GetLayer(AnimatorController controller, string layerName)
    {
        int layerCount = controller.layers.Length;
        for (int i = 0; i < layerCount; i++)
        {
            if (controller.layers[i].name == layerName)
            {
                return controller.layers[i];
            }
        }
        return null;
    }

    private int GetStateIndex(AnimatorController controller, string stateName)
    {
        int stateCount = controller.layers[0].stateMachine.states.Length;
        for (int i = 0; i < stateCount; i++)
        {
            if (controller.layers[0].stateMachine.states[i].state.name == stateName)
            {
                return i;
            }
        }
        return -1;
    }

    private int GetLayerIndex(AnimatorController animatorController, string layerName)
    {
        int layerCount = animatorController.layers.Length;
        for (int i = 0; i < layerCount; i++)
        {
            if (animatorController.layers[i].name == layerName)
            {
                return i;
            }
        }
        return -1;
    }

    public static AnimatorState GetParentState(AnimatorController controller, AnimatorStateTransition transition)
    {
        AnimatorControllerLayer[] layers = new AnimatorControllerLayer[controller.layers.Length];
        for (int i = 0; i < controller.layers.Length; i++)
        {
            layers[i] = controller.layers[i];
            var layer = layers[i];
            var stateMachine = layer.stateMachine;
            for (int j = 0; j < stateMachine.states.Length; j++)
            {
                var childState = stateMachine.states[j];
                for (int k = 0; k < childState.state.transitions.Length; k++)
                {
                    var stateTransition = childState.state.transitions[k];
                    if (stateTransition == transition)
                    {
                        return childState.state;
                    }
                }
            }
        }
        return null;
    }

    public static AnimatorState GetSourceState(AnimatorController controller, AnimatorStateTransition transition)
    {

        AnimatorControllerLayer[] layers = new AnimatorControllerLayer[controller.layers.Length];
        for (int i = 0; i < controller.layers.Length; i++)
        {
            layers[i] = controller.layers[i];
            var layer = layers[i];
            var stateMachine = layer.stateMachine;
            for (int j = 0; j < stateMachine.states.Length; j++)
            {
                var childState = stateMachine.states[j];
                for (int k = 0; k < childState.state.transitions.Length; k++)
                {
                    var stateTransition = childState.state.transitions[k];
                    if (stateTransition == transition)
                    {
                        return childState.state;
                    }
                }
            }
        }
        return null;
    }

    private void test()
    { Debug.Log("LOGDELAYS"); }


 //Transition Functions----------------------------------------------------------------------------------------------------------------------------


//Defining method for getting transitions conditions:
    public static List<Condition> GetTransitionConditions(AnimatorStateTransition transition)
    {
        List<Condition> conditions = new List<Condition>();
        foreach (var condition in transition.conditions)
        {
            conditions.Add(condition);
        }
        return conditions;
    }

//Set Transition Conditions
public static void SetConditions(AnimatorStateTransition transition, List<Condition> conditions)
    {
        foreach (var condition in conditions)
        {
            transition.AddCondition(condition.mode, condition.threshold, condition.parameter);
        }
    }

   

    private bool HasTransition(AnimatorController controller, string sourceStateName, string destinationStateName)
    {
        int stateCount = controller.layers[0].stateMachine.states.Length;
        for (int i = 0; i < stateCount; i++)
        {
            if (controller.layers[0].stateMachine.states[i].state.name == sourceStateName)
            {
                int transitionCount = controller.layers[0].stateMachine.states[i].state.transitions.Length;
                for (int j = 0; j < transitionCount; j++)
                {
                    if (controller.layers[0].stateMachine.states[i].state.transitions[j].destinationState.name == destinationStateName)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }




}


